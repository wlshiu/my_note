void my_memcpy( char* to, char* from, size_t count )
{
    do {                          /* count > 0 assumed */
        *to++ = *from++;            /* Note that the 'to' pointer is NOT incremented */
    } while(--count > 0);
}

void duff_memcpy( char* to, char* from, size_t count )
{
    size_t n = (count+7)/8;
    switch( count%8 )
    {
        case 0: do{ *to++ = *from++;
        case 7:     *to++ = *from++;
        case 6:     *to++ = *from++;
        case 5:     *to++ = *from++;
        case 4:     *to++ = *from++;
        case 3:     *to++ = *from++;
        case 2:     *to++ = *from++;
        case 1:     *to++ = *from++;
                }while(--n>0);
    }
}

這段代碼的確很簡潔, 也是正確的, 而且生成的機器碼也比send函數短很多. 但是卻忽略了一個因素：執行效率.
計算一下就可以知道, my_memcpy函數裡面的循環條件, 即i和count的比較運算的次數, 是達夫設備的8倍！
在做整數賦值這種耗時很少的工作時, 這種耗時相對較高的比 較工作是會大大地影響函數整體的效率的.
達夫設備則是一種非常巧妙的解決辦法(當然, 它利用到了編譯器的一些實現上的工作),
而且如果把8換成更大的數的話, 效率就還可以提高！

它的思路是這樣的：
把原數組以8個char為單位分成若干個小組, 複製的時候以小組為單位複製, 即一次複製8個char.
也就是說, 在my_memcpy函數中以一次比較運算的代價換來1個char的複製,
而在達夫設備中, 卻能以一次比較運算的代價換來8個char的複製.
而switch語句則是用來處理分組時剩下的不到8個的char(這些剩餘的不是數組最後的, 而是數組最開始的), 很巧妙.

總結：像達夫設 備這樣的代碼, 從語言的角度來看, 我個人覺得不值得我們借鑑.
      因為這畢竟不是「正常」的代碼, 至少C/C++標準不會保證這樣的代碼一定不會出錯.
      另外,  這種代碼估計有很多人根本都沒見過, 如果自己寫的代碼別人看不懂,
      這也會是一件很讓人頭疼的事. 然而, 從算法的角度來看,
      我覺得達夫設備是個很高效、很值得我們去學習的東西.
      把一次消耗相對比較高的操作「分攤「到了多次消耗相對比較低的操作上面,
      就像vector<T>中實現可變長度的數組的 思想那樣, 節省了大量的機器資源,
      也大大提高了程序的效率. 這是值得我們學習的.

