
[shell] 2>&1 是什麼意思

當我初次接觸shell script時,看別人寫的script或者範例時, 2>&1這類型的符號真困擾我.
找到了一篇文章,和各位分享 原文 http://bowen.blog.51cto.com/136148/94406
0 代表鍵盤輸入
1 代表螢幕輸出
2 代表錯誤輸出
 linux shell 中"2>&1"含義
腳本是:
      nohup /mnt/Nand3/H2000G  >/dev/null  2>&1  &
       對於& 1 更準確的說應該是檔描述符 1,而1 一般代表的就是STDOUT_FILENO,實際上這個操作就是一個dup2(2)調用.
       他標準輸出到all_result ,然後複製標準輸出到檔描述符2(STDERR_FILENO),其後果就是檔描述符1和2指向同一個檔表項,
       也可以說錯誤的輸出被合併了.其中0 表示鍵盤輸入 1表示螢幕輸出 2表示錯誤輸出.
       把標準出錯重定向到標準輸出,然後扔到/DEV/NULL下面去。
       通俗的說，就是把所有標準輸出和標準出錯都扔到垃圾桶裡面。
      command >out.file  2>&1 &
      command >out.file是將command的輸出重定向到out.file檔，即輸出內容不列印到螢幕上，而是輸出到out.file文件中。
      2>&1 是將標準出錯重定向到標準輸出，這裡的標準輸出已經重定向到了out.file檔，即將標準出錯也輸出到out.file文件中。
      最後一個& ， 是讓該命令在後臺執行。

      試想2>1代表什麼，2與>結合代表錯誤重定向，而1則代表錯誤重定向到一個檔1，而不代表標準輸出；
換成2>&1，&與1結合就代表標準輸出了，就變成錯誤重定向到標準輸出.

      你可以用
            ls 2>1測試一下，不會報沒有2檔的錯誤，但會輸出一個空的檔1；
            ls xxx 2>1測試，沒有xxx這個檔的錯誤輸出到了1中；
            ls xxx 2>&1測試，不會生成1這個檔了，不過錯誤跑到標準輸出了；
            ls xxx >out.txt 2>&1, 實際上可換成 ls xxx 1>out.txt 2>&1；重定向符號>預設是1,錯誤和輸出都傳到out.txt了。
      為何2>&1要寫在後面？
      command > file 2>&1
       首先是command > file將標準輸出重定向到file中， 2>&1 是標準錯誤拷貝了標準輸出的行為，也就是同樣被重定向到file中，最終結果就是標準輸出和錯誤都被重定向到file中。
      command 2>&1 >file
      2>&1 標準錯誤拷貝了標準輸出的行為，但此時標準輸出還是在終端。>file 後輸出才被重定向到file，但標準錯誤仍然保持在終端。

用strace可以看到：
1. command > file 2>&1
這個命令中實現重定向的關鍵系統調用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)

2. command 2>&1 >file
這個命令中實現重定向的關鍵系統調用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)




1、字符串判斷
str1 = str2　　　　　　當兩個串有相同內容、長度時為真
str1 != str2　　　　　 當串str1和str2不等時為真
-n str1　　　　　　　 當串的長度大於0時為真(串非空)
-z str1　　　　　　　 當串的長度為0時為真(空串)
str1　　　　　　　　   當串str1為非空時為真

-eq 等於
-ne 不等於
-gt 大於
-lt 小於
-le 小於等於
-ge 大於等於
-z 空串
= 兩個字符相等
!= 兩個字符不等
-n 非空串文件比較運算符

2、數字的判斷
int1 -eq int2　　　　兩數相等為真
int1 -ne int2　　　　兩數不等為真
int1 -gt int2　　　　int1大於int2為真
int1 -ge int2　　　　int1大於等於int2為真
int1 -lt int2　　　　int1小於int2為真
int1 -le int2　　　　int1小於等於int2為真

3 文件的判斷
–b 當file存在並且是塊文件時返回真
-c 當file存在並且是字符文件時返回真
-d 當pathname存在並且是一個目錄時返回真
-e 當pathname指定的文件或目錄存在時返回真
-f 當file存在並且是正規文件時返回真
-g 當由pathname指定的文件或目錄存在並且設置了SGID位時返回為真
-h 當file存在並且是符號鏈接文件時返回真，該選項在一些老系統上無效
-k 當由pathname指定的文件或目錄存在並且設置了「粘滯」位時返回真
-p 當file存在並且是命令管道時返回為真
-r 當由pathname指定的文件或目錄存在並且可讀時返回為真
-s 當file存在文件大小大於0時返回真
-u 當由pathname指定的文件或目錄存在並且設置了SUID位時返回真
-w 當由pathname指定的文件或目錄存在並且可執行時返回真。一個目錄為了它的內容被訪問必然是可執行的。 

3、複雜邏輯判斷
-a 　 　　　　　 與
-o　　　　　　　 或
!　　　　　　　　非







$#	參數的數目
$*	代表所有參數
$?	Exit status of previous command
$$	PID of this shell's process
$!	PID of the most recently started backgr

#------------------------------

為了完整起見，我這裡再用一些例子加以說明 ${ } 的一些特異功能：
假設我們定義了一個變量為：
file=/dir1/dir2/dir3/my.file.txt
我們可以用 ${ } 分別替換獲得不同的值：
${file#*/}：拿掉第一條 / 及其左邊的字符串：dir1/dir2/dir3/my.file.txt
${file##*/}：拿掉最後一條 / 及其左邊的字符串：my.file.txt
${file#*.}：拿掉第一個 .  及其左邊的字符串：file.txt
${file##*.}：拿掉最後一個 .  及其左邊的字符串：txt
${file%/*}：拿掉最後條 / 及其右邊的字符串：/dir1/dir2/dir3
${file%%/*}：拿掉第一條 / 及其右邊的字符串：(空值)
${file%.*}：拿掉最後一個 .  及其右邊的字符串：/dir1/dir2/dir3/my.file
${file%%.*}：拿掉第一個 .  及其右邊的字符串：/dir1/dir2/dir3/my
記憶的方法為：
[list]# 是去掉左邊(在鑑盤上 # 在 $ 之左邊)
% 是去掉右邊(在鑑盤上 % 在 $ 之右邊)
單一符號是最小匹配﹔兩個符號是最大匹配。[/list]
${file:0:5}：提取最左邊的 5 個字節：/dir1
${file:5:5}：提取第 5 個字節右邊的連續 5 個字節：/dir2

我們也可以對變量值裡的字符串作替換：
${file/dir/path}：將第一個 dir 提換為 path：/path1/dir2/dir3/my.file.txt
${file//dir/path}：將全部 dir 提換為 path：/path1/path2/path3/my.file.txt

利用 ${ } 還可針對不同的變量狀態賦值(沒設定、空值、非空值)：
${file-my.file.txt} ：假如 $file 沒有設定，則使用 my.file.txt 作傳回值。(空值及非空值時不作處理)
${file:-my.file.txt} ：假如 $file 沒有設定或為空值，則使用 my.file.txt 作傳回值。 (非空值時不作處理)
${file+my.file.txt} ：假如 $file 設為空值或非空值，均使用 my.file.txt 作傳回值。(沒設定時不作處理)
${file:+my.file.txt} ：若 $file 為非空值，則使用 my.file.txt 作傳回值。 (沒設定及空值時不作處理)
${file=my.file.txt} ：若 $file 沒設定，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (空值及非空值時不作處理)
${file:=my.file.txt} ：若 $file 沒設定或為空值，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (非空值時不作處理)
${file?my.file.txt} ：若 $file 沒設定，則將 my.file.txt 輸出至 STDERR。 (空值及非空值時不作處理)
${file:?my.file.txt} ：若 $file 沒設定或為空值，則將 my.file.txt 輸出至 STDERR。 (非空值時不作處理)




