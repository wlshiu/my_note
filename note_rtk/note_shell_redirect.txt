
[shell] 2>&1 是什麼意思

當我初次接觸shell script時,看別人寫的script或者範例時, 2>&1這類型的符號真困擾我.
找到了一篇文章,和各位分享 原文 http://bowen.blog.51cto.com/136148/94406
0 代表鍵盤輸入
1 代表螢幕輸出
2 代表錯誤輸出
 linux shell 中"2>&1"含義
腳本是:
      nohup /mnt/Nand3/H2000G  >/dev/null  2>&1  &
       對於& 1 更準確的說應該是檔描述符 1,而1 一般代表的就是STDOUT_FILENO,實際上這個操作就是一個dup2(2)調用.
       他標準輸出到all_result ,然後複製標準輸出到檔描述符2(STDERR_FILENO),其後果就是檔描述符1和2指向同一個檔表項,
       也可以說錯誤的輸出被合併了.其中0 表示鍵盤輸入 1表示螢幕輸出 2表示錯誤輸出.
       把標準出錯重定向到標準輸出,然後扔到/DEV/NULL下面去。
       通俗的說，就是把所有標準輸出和標準出錯都扔到垃圾桶裡面。
      command >out.file  2>&1 &
      command >out.file是將command的輸出重定向到out.file檔，即輸出內容不列印到螢幕上，而是輸出到out.file文件中。
      2>&1 是將標準出錯重定向到標準輸出，這裡的標準輸出已經重定向到了out.file檔，即將標準出錯也輸出到out.file文件中。
      最後一個& ， 是讓該命令在後臺執行。

      試想2>1代表什麼，2與>結合代表錯誤重定向，而1則代表錯誤重定向到一個檔1，而不代表標準輸出；
換成2>&1，&與1結合就代表標準輸出了，就變成錯誤重定向到標準輸出.

      你可以用
            ls 2>1測試一下，不會報沒有2檔的錯誤，但會輸出一個空的檔1；
            ls xxx 2>1測試，沒有xxx這個檔的錯誤輸出到了1中；
            ls xxx 2>&1測試，不會生成1這個檔了，不過錯誤跑到標準輸出了；
            ls xxx >out.txt 2>&1, 實際上可換成 ls xxx 1>out.txt 2>&1；重定向符號>預設是1,錯誤和輸出都傳到out.txt了。
      為何2>&1要寫在後面？
      command > file 2>&1
       首先是command > file將標準輸出重定向到file中， 2>&1 是標準錯誤拷貝了標準輸出的行為，也就是同樣被重定向到file中，最終結果就是標準輸出和錯誤都被重定向到file中。
      command 2>&1 >file
      2>&1 標準錯誤拷貝了標準輸出的行為，但此時標準輸出還是在終端。>file 後輸出才被重定向到file，但標準錯誤仍然保持在終端。

用strace可以看到：
1. command > file 2>&1
這個命令中實現重定向的關鍵系統調用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)

2. command 2>&1 >file
這個命令中實現重定向的關鍵系統調用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)




1、字符串判斷
str1 = str2　　　　　　當兩個串有相同內容、長度時為真
str1 != str2　　　　　 當串str1和str2不等時為真
-n str1　　　　　　　 當串的長度大於0時為真(串非空)
-z str1　　　　　　　 當串的長度為0時為真(空串)
str1　　　　　　　　   當串str1為非空時為真
2、數字的判斷
int1 -eq int2　　　　兩數相等為真
int1 -ne int2　　　　兩數不等為真
int1 -gt int2　　　　int1大於int2為真
int1 -ge int2　　　　int1大於等於int2為真
int1 -lt int2　　　　int1小於int2為真
int1 -le int2　　　　int1小於等於int2為真
3 文件的判斷
-r file　　　　　用戶可讀為真
-w file　　　　　用戶可寫為真
-x file　　　　　用戶可執行為真
-f file　　　　　文件為正規文件為真
-d file　　　　　文件為目錄為真
-c file　　　　　文件為字符特殊文件為真
-b file　　　　　文件為塊特殊文件為真
-s file　　　　　文件大小非0時為真
-t file　　　　　當文件描述符(默認為1)指定的設備為終端時為真
3、複雜邏輯判斷
-a 　 　　　　　 與
-o　　　　　　　 或
!　　　　　　　　非







$#	參數的數目
$*	代表所有參數
$?	Exit status of previous command
$$	PID of this shell's process
$!	PID of the most recently started backgr






